---
title: Javascript 산술연산자
tags: 산술연산자
article_header:
  type: cover
  image:
    src: /screenshot.jpg
---

산술 연산자를 통해 숫자를 조작 합니다.



```js
//  첫번째 인자는 계산할 값이 들어오고 두인짜값이 '승' 이 됩니다. 
Math.pow(2,53) 
// 1과 가장 가까운 정수로 반올림 합니다. 
Math.round(.3) // 3
Math.round(-.3) // -3

// 정수로 올린 값을 반환 합니다,
Math.ceil(.6)

// 정수로 내린 값을 반환합니다.
Math.floor(.6) // 0.0 정수로 내립니다.

// 인자 중 가장 큰 값을 반환 합니다.
Math.max(x,y,z)  

//  인자 중 가장 작은 값을 반환 합니다.
Math.min

// 0 이상 1.0 미만의 랜덤한 숫자를 반환 합니다.
Math.random() 

// 원주율 값을 반환 합니다.
Max.PI 

// math.E , e 자연 로그의 밑 
Math.E 

//  3**(1/3) => 3의 세제곱근을 반환 합니다.
Math.sqrt(3)

// 삼각함수, Math.cos, Math.atan 등도 있음
Math.sin 

// 10의 자연 로그 
Math.log 

// 100의 상용 로그 
Math.log(100)/Math.LN10 

// 512의 이진 로그
Math.log(512)/math.LN2 

// Math.E 의 세제곱
Math.exp(3)


// ES6에서 Math 객체에 함수가 더 추가됨 

// Math.cbrt(27)
Math.cbrt(27) 


// 인자의 제곱의 합의 제곱근
Math.hypot(3,4)

// 1+x의 자연로그, x가 아주 작아야 정확함

Math.log1p(x)

// Math.expm1(x)
Math.exp(x)-1: Math.log1p()의 역 

// 인자의 부호에 따라 -1, 0, 1을 반환
math.sign(x) 

// 6: C언어의 방식을 차용한 32비트의 정수의 곱셈 
Math.imul(2,3)

// 28: 32비트 정수에서 맨 앞의 0비트 개수 
Math.Clz32(0xf)

// 3 소수점 아래를 잘라 내어 정수로 변환 
// Math.trunc(3.9)

// 가장 가까운 32비트 부동 소수점 숫자로 반올림
Math.fround(x)



//  하이퍼블릭 사인, Math.cosh(), Math.tanh() 도 있음
Math.sinh(x)

// 하이퍼블릭 아크사민, Math.acosh(), Math.atanh() 도 있음
Math.asinh(x) 


```

문자열 다루기 
자바스크립트는 문자열을 병합(연결)하는 기능이 내장되어 있습니다.
+ 연산자를 수자와 함께 쓰면 이 연산자는 숫자를 더합니다.
+ 연산자를 문자열에 쓰면 두번째 문자열을 첫번째 문자열 뒤에 이어 붙입니다.

```js 
let msg = "Hello" + "World" 
let greeting = "Welcome to my blog" + " " + name;
```

문자열을 비교할 떄는 일치 연산자 === 와 불일치 연산자 !== 가 표준 입니다.
두 문자열이 정확히 같은 16비트 값의 연속으로 이루어졌을 때만 일치 합니다.
문자열은 >, <=, >, >= 연산자로 비교할 수도 있습니다.
문자열 비교는 16비트 값을 비교하는 방식으로 이루어 집니다.
지역 특성을 감안한 문자열 비교와 정렬에 대해서는 추후에 다루겠습니다.

문자열의 길이 즉, 그 안에 포함된 16비트 값의 개수는 length 와 프로퍼티로 알 수 있습니다.

```js 
s.length
```

Javascript 에는 LENGTH 프로퍼티 외에도 다양한 문자열 API가 있습니다.

```js
// 문자열의 일부를 가져 옵니다. 
let s = "Hello World"; 
s.sbutstring(1,4) // ell , 두번째, 세번째, 네번째 문자
s.slice(1,4) // ell 과 같은 결과 입니다.
s.split(", ") // ["Hello", "World"] 구분자를 기준으로 나눕니다.


// 문자열 검색
s.indexOf("l")  // 2 , l이 처음에 나타나는 위치 입니다.
s.indexOf("l", 3) // 3 , 3번 문자부터 시작해 l이 처음에 나타나는 위치 입니다.
s.indexOf("zz") // -1 
s.lastIndexOf("l") // 10: l이 마지막으로 나타나는 위치 

// 불을 반환하는 검색 함수는 ES6에서 추가 했습니다.

s.startWith("Hell")
s.endWidth("!")
s.includes("or")

// 문자열을 변경 합니다.
s.replace("llo", "ya");
s.toLowerCase(); // 전부 소문자로 반환
s.toUpperCase(); // 전부 대문자로 반환

// 유니코드 NFC 정규화는 ESC6에서 추가 했습니다.
s.normalize();
// NFD 정규화, NFKC, NFKD 도 있습니다.
s.normailze("NFD");

// 문자열의 각 16비트 문자를 검사 합니다.
s.charAt(0); // 첫번째 문자
s.charAt(s.length-1); // 마지마 문자
s.charCodeAt(0); // 주어진 위치의 16비트 숫자
s.codePointAt(0); // 16비트보다 큰 코트 포인트에서 동작하는 ES6 기능

// 패딩 함수는 ES2017 에서 추가
"x".padStart(3) // 왼쪽에 스페이스 세 개를 더하 
"x".padEnd(3) // 오른쪽에 스페이스 세개를 더함
"x".padStart(3, "*") // *를 왼쪽에 붙여 길이를 3에 맞춥니다.
"x".padEnd(3, "-") // "x--" -를 오른쪽에 붙여 길이를 3에 맞춥니다.

// 공백 제거 trim() 
"test".trim();
"test".trimStart();
"test".trimEnd();

// 그 외에 문자열 메서드 
s.concat("!") // "Hello, World": + 연산자를 쓰는게 더 간단합니다.
"<>".repeat(5) // <><><><> 를 n번 반복 합니다.
```

replace() 나, toUpperCase() 같은 메서드는 기존 문자열을 수정하는 것이 아니라 새 문자열을 반환 합니다.
문자열은 읽기 전용 배열로 취급할 수도 있으며, 다음과 같으 CharAt() 메서드 대신 대괄호 안에 써서 문자열의 개별 문자(16비트 값)에
접근할 수 ㅇㅆ습니다.

```js

let s = "hello world";
s[0];
s[s.length-1]
```

템플릿 리터럴 

ES6부터는 백턱으로 감싼 문자열 리터럴을 사용할 수 있습니다.

let s = "hello world";
하지만 이것은 일반적인 문자열 리터럴 문법과는 다르게, 임의의 자바스크립트 표현식을 넣을 수 있는 템플릿 리터럴 입니다.
백턱으로 둘러싼 문자열 리터럴의 최종 값은 그 안에 포함된 표현식을 평가해서 그 표현식의 값을 문자열로 반환한 다음, 변환된 문자열을
백터 안에 들어있는 리터럴 문자와 결합한 값으로 결정 됩니다.


```js 
let name = "Bell";
let greeting = `Hello ${name}.`; // greeting = "Hello Buill."
```



"$"{와 짝을 이루는} 안에 있는 것은 모두 자바스크립트 표현식으로 해석 됩니다. 
중괄호 밖에 있는 것은 모두 일반적인 문자열 리터럴 텍스트 입니다. 중괄호 안의 표현식으로 평가하고 
문자열로 변환한 후 템플릿에 삽입할 때 달러 기호와 중괄호, 그 안에 있는 것을 대체 합니다.
템플릿 리터럴 안에 쓸 수 있는 표현식 개수에는 제한이 없습니다. 일반적인 문자열에 쓸 수 있는 이스케이프 문자는
전부 쓸 수 있고, 특별한 이스케이프 없이 몇행에 걸쳐 써도 무방 합니다.
다음 템플릿 리터럴에는 자바스크립트 표현식이 네 개, 유니코드 이스케이프 시퀀스 하나, 최소 네 개의 뉴 라인이 들어 갑니다. ( 표현식 값에도 뉴 라인이 들어갈 수 있으므로)

 

태그된 템플릿 리터럴 

템플릿 리터럴에는 강력하지만 잘 사용되지 않는 기능이 하나 있습니다. 이는 백터 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달 됩니다.이 태그된 탬플릿 리터럴의 값이 함수의 반환 값 입니다.
이 기능은 예를 들어 HTML 이나 SQL 을 텍스트에 붙이기 전에 이크세이프하는 용도로 사용할 수 있습니다.
ES6에는 내장된 태그 함수 String.raw() 가 있습니다. 이 함수는 역슬래시 이스케이프를 처리하지 않고 백터 안에 텍스트를 반환 합니다. 


```js 
1 => 이 문자열에는 뉴라인 문자 하나만 있습니다.
'\n'.length 
2 => 역슬래시 문자와 n 이 있습니다.
String.raw'\n\.length
```


패턴 매칭 


```js
/^HTML/; //  문자열의 시작 부분에 있는 H T M L 에 일치 합니다.
/[1-9][0-9]*/; // 0 이 아닌 숫자가 하나 있어야 하고, 그 뒤의 숫자는 제한이 없습니다.
/\bjavascript\b/i // javascript 가 한단어로 들어가아 하고 대소문자를 구분하지 않습니다.


let text = "testing: 1,2,3"; // 샘플 텍스트
let pattern = /\d+/g;  // 연속된 숫자 전체에 일치 합니다.
pattern.test(text); // true 패턴에 맞는 것이 있습니다.
text.search(pattern); // 9: 첫 번쨰로 일치하는 부분위 위치
text.match(pattern); // ["1", "2", "3"]: 일치하는 부분이 모두 포함된 배열
text.replace(pattern, "#"); // "testing: #, #, #"
text.split(/\d+/) // ["", "1", "2", "3" ] 숫자가 아닌 것에서 나눕니다.
```

Bool 값 
Bool 값은 참 또는 거짓을 표현 합니다. 이 타입에는 단 두가지 값만 존재 합니다.
바로 예약어인 true 와 flase 입니다.
Bool 값은 일반적으로 비교 결과를 나타냅니다. 예를 들어 다음을 보십시오.

a === 4

이 코드는 벼눗 a와 같이 숫자 4와 일치하는지 검사합니다. 일치한다면 이 비교 결과는 불 값 true 입니다.
a가 4와 일치하지 않는다면 비교 결과는 false 입니다.
Bool 값은 제어문에서 자주 사용 됩니다. 예를 들어 if/else 문은 불 값이 true 일 때 한가지 행동을 취하고, 
값이 false 일 때 다른 행동을 취합니다. 보통은 불 값을 반환하는 비교 표현식과 그 결과를 사용하는 문을 조합해 씁니다.
즉 다음과 같은 형태 입니다.

```js 
if (a===4) {
  b = b + 1;
} else {
  a = a + 1;
}
```

이 코드는 a과 4가 일치하는지 검사합니다. 일치한다면 b에 1을 더하고, 일치하지 않는다면 a에 1을 더합니다. 
Javascript 값은 모두 Bool 값으로 변환될 수 있습니다. 다음 값은 모두 false로 변환되며, 따라서 false 처럼 동작 합니다. 


```js
undefined 
null 
0
-0
NaN
"" // 빈 문자열  
```

객체와 배열을 포함해 다른 값은 모두 true로 변환되며 true 처럼 동작 합니다. 
flase 그리고 false로 변환되는 여섯 가지 값을 묶어서 false 같은 (falsy) 값이라고 부르고,
나머지 값을 true 같은 (trunhy) 값이라고 부릅니다. 자바스크립트에서 Bool 값을 예상하는 곳에서 false 같은 값은
false 처럼 동작하고 true 같은 값은 true 철머 동작 합니다. 

예를 들어 변수 o는 개체 또는 null 값이 할당된다고 합시다. 다음과 같이 o가 null 인지 명시적으로 확인하는 if문을 쓸 수 있습니다.

if( o !== null )...

일치 연산자는 o와 null을 비교해 true 나 false 로 평가합니다. null은 false 같은 값이며 객체는 true 같은 값이라는 점을 이용해
다음과 같이 비교를 생략할 수도 있습니다.

if (o) ...

첫 번째 예제는 o가 null 이 아닐 떄만 if 의 바디가 실행 됩니다. 두 번째 예제는 그 정도로 엄격하지는 않습니다.
o가 false, 또는 false 같은 값이 아니면 if



null 
값이 없음을 나타날 떄 사용하는 특별한 값 입니다.
null 에 typeof 연산자를 사용하면 분자열 "object"를 반환하는데, 이로 미루어 null 은 '객체가 없다'는 것을 나타내는 
특별한 객체 값이라고 볼 수 있습니다. 하지만 현실에서 null은 해당 타입의 유일한 맴버로 인식되며, 객체 뿐 이나라 숫자나 
문자열에도 "값이 없다"는 의미로 사용될 수 있습니다. 



undefined  
이 값은 초기화 되지 않은 변수의 값이며 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을떄 반환되는 값 입니다.
또한 값을 명시적으로 반환하지 않는 함수의 반환 값이며, 전달되지 않은 인자의 값이기도 합니다. 
undefined 는 미리 정의된 전역 상수이며, 그 값은 undeinfed 로 초기화 됩니다. 

undefined 에 typeof 연산자를 적용하면 문자열 "undefined"를 반환 합니다. 
undeinfed 역시 특별한 타입이고 맴버는 그 하나뿐이라는 뜻 입니다. 

차이는 있지만 null 과 undeinfed 는 모두 값이 없다는 뜻이고 서로 바꿔 쓸 수 있을 떄가 많습니다. 
동등 연산자 == 는 두 값이 동등하다고 간주 합니다. 일치 연산자ㅡ === 는 두 값을 구분 합니다. 
둘 다 false 같은 값이므로 bool 값을 써야하는 곳에서는 false 로 동작 합니다. 
null과 undefined 는 모두 프로퍼티나 메서드가 없습니다. 점연산자나 대괄호를 써서 이들 값에 접근하려 하면 
TypeError 가 일어납니다. 

undefined 를 시스템 레벨이고 예측되지 않았거나 에러 비슷한 상황에서 값이 없는 것이 아니라 간주하고, 
반대로 null은 프로그램 레벨이고 정상적이거나 예측된 상황에서 값이 없는 것이라 간주 합니다. 
이 책에서는 가능한 한 null이나 undefined 를 쓰지 않으려 하지만, 이들 중 하나를 변수나 프로퍼티에 할당하거나 
함수와 주고받아야 한다면 보통 null을 사용 합니다. 반대로 null을 완전히 피하고 undefined만 사용하려 하는 사람도 있습니다.


Symbol 

문자열이 아닌 프로퍼티 이름으로 ES6에서 추가 됐습니다.
심벌을 이해하기 위해서는 자바스크립트의 객체 타입이 프로퍼티의 순서 없는 집합이며 각 프로퍼티에 이름과 값이 
있다는 것을 이해해야 합니다. 프로퍼티 이름은 일반적으로 문자열 입니다.(ES6 전에는 오로지 문자열 이었습니다.)
하지만 ES6 이후에는 심벌 역시 문자열과 같은 목적으로 사용할 수 있습니다.

```js
let strname = "string name";
let symname = Symbol("propname");
typeof strname 
typeof symname
let o = {};
o[strname] = 1;
o[symname] = 2;
o[strname] // 1
o[symname] // 2

```

Symbol Type 에는 리터럴 문법이 없습니다. 
Symbol 값을 가져올 떄는 Symbol() 함수를 호출합니다. 
이 함수는 절대 같은 값을 반환하지 않습니다. 같은 인자로 호출하더라도 다른 값을 반환 합니다.

Symbol() 은 호출해 심벌 값을 얻었다면 객체의 기존 프로퍼티를 같은 이름으로 덮어 쓸 염려 없이 그 값을 프토퍼티 이름으로 
추가할 수 있다는 뜻 입니다. 마찬가지로 심벌인 프로퍼티 이름을 사용하고 그 심벌을 공유하지 않는다면 프로그램의 다른 모듈에서 시룻로 여러분의 프로퍼티를 덮어 쓸 일이 없다는 뜻이기도 합니다. 

심벌은 사실 자바스크립트 언어를 확장하는 매커니즘 입니다. ES6 에서 for/of 루프와 이터러블 객체를 도입했을 때 클래스가 자기 자신을 이터러블로 만들 수 있는 표준 메서드를 정의해야 했습니다. 하지만 특정 문자열 이름을 이터레이터 메서드로 표준화하면 기존코드가 깨지는 것을 피할수 없었기에 심벌 이름을 도입한 것입니다. 


Symbol() 함수는 선택새항이 인자로 문자열을 받고 고유한 심벌 값을 반환 합니다.
문자열 인자를 전달하면 그 문자열은 Symbol 의 toString() 메서드 결과에 포함 됩니다. 
하지만 같은 문자열을 전달해 Symbol() 을 다시 호출하더라도 그 결과는 완전히 다른 값 입니다. 

```js
let s = Symbol("sym_x")
s.toString(); 


```


심벌 인스턴스에서 흥미로운 메서드는 toString() 하나 뿐 입니다. 하지만 알아둬야 할 심벌 관련 함수가 두 개 있습니다.
심벌을 쓸 때 그 심벌을 여러분의 코드에만 쓸 수 있도록 비공개로 두어 다른 코드의 프로퍼티와 충돌하지 않게 하고 싶을 때가 있을 겁니다. 반대로 다른 코드에서도 쓸 수 있도록 Symbol 을 정의하고 공유하고 싶을 수도 있습니다.
후자는 아마 앞에서 언급한 Symbol.iterator 메커니즘 같은 일종의 확장을 만들어 다른 코드에서도 사용할 수 있도로 하는 것과 같습니다.

자바스크립트는 후자에 대응할 수 있도로 ㄱ전역 심벌 레지스트리를 정의 했습니다. 
Symbol.for() 함수는 문자열 인자를 받고 그 문자열과 연관된 심벌 값을 반환 합니다. 그 문자열과 연관된 심벌이 존재하지 않으면 새 심벌을 생성해 반환하고 



flat() 은 배열을 평탄화하며 중첩 요소를 제거 합니다.





A Post with Header Image, See [Page layout](https://kitian616.github.io/jekyll-TeXt-theme/samples.html#page-layout) for more examples.

more

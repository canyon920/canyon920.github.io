---
title: Hoisting Deep Dive
tags: Hoisting, 호이스팅
---

Hoisting Deep Dive


아래의 사과 값은 fruits 입니다.
인터프리터 언어는 밑에서 부터 위로 읽고 내려오며 메모리 스택에 코드들을 담아둡니다.

```js
var fruits = "사과"
{
  console.log(fruits)
  var frtuis = "바나나"
}
```

var 는 전역 변수 입니다. 
Blcok Scope 속성을 무시 합니다.


분명히 var를 적지 않고 변수를 선언할 시에도 마찬가지로 전역 변수로 지정이 됩니다.
하지만 아래와 같은 문법을 지정하게 되면 사과와 과일이 같이 출력이 됩니다.


이것은 단순한 Javascript의 오류로 볼 수 있습니다.


```js
var fruits = "사과"
{
  console.log("fruits")
  frtuis = "과일""  
}
```

이러한 점을 오류라고 예측할 수 있는 부분은 아래와 같습니다.
아래와 같은 코드는 참조 오류(Referrence Error) 를 반환 합니다.


```js 
let frtuis = "사과"
{
  console.log("fruits")
  fruits ="과일"
}
```

Hoisting 은 var에서만 동작하는 것은 아닙니다.
다만 참조하게 될 경우 참조 오류(Referrence Error)가 발생할 뿐입니다.

이러한 부분을 봤을때 var로 선언을 하든 안하든 그 원시 데이터는 전역변수로 생성이 되고
var를 선언하지 않고 원시 데이터를 생성하면 그 데이터는 그 하단에 선언된 과일이 같이 출력이 됩니다.


var 를 선언하고 안하고의 메모리 스택 부분에서 차이점이 있는 것으로 추측하고 넘어가도록 하겠습니다.


이러한 Hoisting은 if문 혹은 for 문과 같은 Scope 속성을 지닌 예약어에서도 똑같이 동작 합니다.




function sayHi(){
  if (true){
    var pahrse = "Hello";
  }
  alert(pharse);
}
sayHi();

alert(pahrse); // Error is not defined;
 


# 코드, 데이터, 힙, 스택 으로 알아보는 Hoisting


이 때 메모리 영역이 네가지 영역으로 구분되어 데이터를 저장하고 처리하는데 이 때 원시 값도 같이 가져와서, 메모리 공간을 얼마나 사용할지 사전에 정의 합니다.
Javascript가 실행이 되면서 메모리의 코드 영역에 코드가 저장되어 코드를 해석하고, 메모리 공간을 찾아 선언한 변수의 이름을 붙이며, 우리가 임의로는 수정이 불가능 합니다.  

개발자가 원시 값을 변수에 할당하면, 변수에 실제 값이 복사되어 저장
```
String, Number, Boolean, undefiend, Symbol, Null
```

Javascript 는 이 원시값을 받아와서 메모리 공간을 얼마나 사용할지 사전에 정의하며 Javascript가 실행이 되면서 메모리의 코드 영역에 코드가 저장되어 
코드를 해석하고, 우선 메모리 공간을 찾아 선언한 변수의 이름을 붙이고 임의로는 수정이 불가능 합니다.

개발자가 원시값을 변수에 할당하면, 변수에는 실제 값이 복사되어 저장 됩니다.

Javascript의 모든 선언은 코드 영역에서 해석하고, 변수명을 메모리에 먼저 할당하며, 이후 코드가 실행되며 값이 등록되며 호이스팅이 일어납니다.
선언문 이전에 이미 변수명이 선언되어 있는 상태로 선언된 코드블럭 이전에 이미 선언되어 호출되어 있는것을 의미 합니다.


```
// 비교 연산자에서 값 자체를 비교하기 때문에 다른 변수명에 저장되어 있어도,복제된 값이어도 같아고 결과가 나옴 
// 동등 연산자 (==, 값이 일치하는지 확인), 일치 연산자 (===, 값과 자료형 모두 일치하는지 비교)

let cat = 'cookie';
let cat2 = 'cookie2';

cat === cagt2;

let cat3 = cat;
cat2 === cat3;
cat1 === cat3;
```


이미 선언되어 있는 변수에 새로운 원시 값을 할당하는 경우 Javascript는 새로운 메모리 공간에 새로 할당되는 값을 복사해 입력하고, 기존에 사용하던 변수명이 이를 가리키게 됩니다.

새로운 변수명에 기존에 있던 변수를 할당하는 경우 새로운 변수명이 새로운 메모리 공간에 할당되고, 그 위치에 기존 변수에 할당되어 있던 값을 그대로 복제하게 됩니다.
원시 값의 불변성은 저장되어 있는 'cookie' => 'cookie2' 처럼 부분적인 변경이나 메모리에 저장되어 있는 값을 수정하는게 불가능 하기 때문에 불변성을 가지고 있다고 합니다.
이 처럼 값을 수정하는, 재할당 하는 경우 동일한 메모리 주소에 저장되어 있는 값을 재할당하는 것이 아닌, 다른 메모리 영역에 저장하고, 그 위치를 가리키게 하고 이전 값, 이후 값 모두 메모리상에 존재하게 됩니다.
더 이상 사용되지 않는 메모리 공간은 가비지 컬렉터에 의해 제거되게 됩니다.
원시 값은 스택 영역에 값 자체를 보관 합니다. 

객체가 생성될 때 힙 영역에 저장하고, 스택 메모리에 힙 영역에 저장주소를 기록 
같은 내용을 가진 객체이지만 다른 주소를 가지고, 다른 영역에 저장하게 됩니다.

참조 타입의 비교는 힙 영역에 저장된 메모리 주소를 비교하기 때문에 객체는 똑같은 값이지만, 실제 Javascript 가 인식하기에는 완전히 다른 힙 영역의 주소를 가리키는 값으로 보게 됩니다.

객체를 복제하는 경우 

새로운 변수에 기존 객체를 할당하는 경우 힙 영역의 위치를 가리키는 주소를 복제 합니다.
변수명은 다르지만 힙 영역에 동일한 객체를 가리키게 되고, 일치 연산자로 cat == cat2 를 하면 true 를 출력하게 됩니다.

Javascript가 참조타입의 데이터를 메모리에 저장하는 이러한 특징 때문에 주의해야 합니다.
위의 경우 cat과 cat2가 하나의 객체를 가리키고 있기 때문에 cat을 수정할 경우 cat2에도 수정된 데이터가 출력되기 때문입니다.

이뉴는 같은 주소를 가리키며 동일한 객체를 공유하고 있기 때문입니다.

이 처럼 객체가 지정된 주소를 복제하는 것을 얕은 복제 라고 합니다.

주소 복제 아닌 다른 메모리에 객체를 똑같이 복제하고 싶다면 깊ㅇ느 복제, Deep Copy를 해야 합니다.
변수명을 복제하지 않고, 객체에 속한 모든 내용을 복제할 수 있고, 이 때 객체 프로퍼티에 참조값이 저장되어 있는 부분을 주의햐 복제를 진행해야 합니다.

객체의 프로퍼티의 값에는 Javascript에서 사용할 수 있는 모든 값들이 사용 가능 합니다.
원시형인 경우 그대로 복제를 진행하면 됩니다. 값이 원시형이 아닌 경우에는 레퍼런스 주소 내부의 값을 복제해 진행할 수 있습니다.
---

React-Hook.html :star2:

[![Star This Project](https://img.shields.io/github/stars/kitian616/jekyll-TeXt-theme.svg?label=Stars&style=social)](https://github.com/canyon920/)
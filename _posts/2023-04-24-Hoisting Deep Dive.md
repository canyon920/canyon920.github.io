---
title: Hoisting Deep Dive
tags: Hoisting, 호이스팅
---

Hoisting Deep Dive


아래의 사과 값은 fruits 입니다.
인터프리터 언어는 밑에서 부터 위로 읽고 내려오며 메모리 스택에 코드들을 담아둡니다.

```js
var fruits = "사과"
{
  console.log(fruits)
  frtuis = "바나나"
}
```

그렇다면 let과 const 는 어떤 차이점이 있을까요?

var는 초기의 자바스크립트 구현방식으로 인해 let 과 const 와는 동작 방식이 다릅니다.

var 는 block scope 가 존재하지 않습니다.


아래와 같이 if 문에 true 를 넣어서 test 를 실행시키면 var에 접근할 수 있습니다.
하지만 var 를 let으로 바꾼다면 아래의 코드는  Error test is not defined 를 반환하죠.
```
if(true){
  var test = true;
}
alert(test)
```

반복문에서도 이는 유사합니다.

```
for (var i=0; i < 10; i++){
  // ...
}
// 반복문이 종료되었지만 이는 여전히 접근 가능한 코드 입니다.
alert(i)
```


function sayHi(){
  if (true){
    var pahrse = "Hello";
  }
  alert(pharse);
}

sayHi();
alert(pahrse); // Error is not defined;
 

 
이러한 이유는 원시값과 객체 메모리에 대한 이해를 하면 좀 더 쉽습니다.

let 으로 데이터를 선언했다고 가정해봅니다,.




프로그램이 실행될 때 코드, 데이터, 힙, 스택으로 구분되어 데이터를 저장하고 처리합니다.
이 때 메모리 영역이 네가지 영역으로 구분되어 데이터를 저장하고 처리하는데 이 때 원시 값도 같이 가져와서, 메모리 공간을 얼마나 사용할지 사전에 정의 합니다.
Javascript가 실행이 되면서 메모리의 코드 영역에 코드가 저장되어 코드를 해석하고, 메모리 공간을 찾아 선언한 변수의 이름을 붙이며, 우리가 임의로는 수정이 불가능 합니다.  

개발자가 원시 값을 변수에 할당하면, 변수에 실제 값이 복사되어 저장
```
String, Number, Boolean, undefiend, Symbol, Null
```

Javascript 는 이 원시값을 받아와서 메모리 공간을 얼마나 사용할지 사전에 정의하며 Javascript가 실행이 되면서 메모리의 코드 영역에 코드가 저장되어 
코드를 해석하고, 우선 메모리 공간을 찾아 선언한 변수의 이름을 붙이고 임의로는 수정이 불가능 합니다.

개발자가 원시값을 변수에 할당하면, 변수에는 실제 값이 복사되어 저장 됩니다.

Javascript의 모든 선언은 코드 영역에서 해석하고, 변수명을 메모리에 먼저 할당하며, 이후 코드가 실행되며 값이 등록되며 호이스팅이 일어납니다.
선언문 이전에 이미 변수명이 선언되어 있는 상태로 선언된 코드블럭 이전에 이미 선언되어 호출되어 있는것을 의미 합니다.


```
// 비교 연산자에서 값 자체를 비교하기 때문에 다른 변수명에 저장되어 있어도,복제된 값이어도 같아고 결과가 나옴 
// 동등 연산자 (==, 값이 일치하는지 확인), 일치 연산자 (===, 값과 자료형 모두 일치하는지 비교)

let cat = 'cookie';
let cat2 = 'cookie2';

cat === cagt2;

let cat3 = cat;
cat2 === cat3;
cat1 === cat3;
```


이미 선언되어 있는 변수에 새로운 원시 값을 할당하는 경우 Javascript는 새로운 메모리 공간에 새로 할당되는 값을 복사해 입력하고, 기존에 사용하던 변수명이 이를 가리키게 됩니다.

새로운 변수명에 기존에 있던 변수를 할당하는 경우 새로운 변수명이 새로운 메모리 공간에 할당되고, 그 위치에 기존 변수에 할당되어 있던 값을 그대로 복제하게 됩니다.
원시 값의 불변성은 저장되어 있는 'cookie' => 'cookie2' 처럼 부분적인 변경이나 메모리에 저장되어 있는 값을 수정하는게 불가능 하기 때문에 불변성을 가지고 있다고 합니다.
이 처럼 값을 수정하는, 재할당 하는 경우 동일한 메모리 주소에 저장되어 있는 값을 재할당하는 것이 아닌, 다른 메모리 영역에 저장하고, 그 위치를 가리키게 하고 이전 값, 이후 값 모두 메모리상에 존재하게 됩니다.
더 이상 사용되지 않는 메모리 공간은 가비지 컬렉터에 의해 제거되게 됩니다.
원시 값은 스택 영역에 값 자체를 보관 합니다. 

객체가 생성될 때 힙 영역에 저장하고, 스택 메모리에 힙 영역에 저장주소를 기록 
같은 내용을 가진 객체이지만 다른 주소를 가지고, 다른 영역에 저장하게 됩니다.

참조 타입의 비교는 힙 영역에 저장된 메모리 주소를 비교하기 때문에 객체는 똑같은 값이지만, 실제 Javascript 가 인식하기에는 완전히 다른 힙 영역의 주소를 가리키는 값으로 보게 됩니다.

객체를 복제하는 경우 

새로운 변수에 기존 객체를 할당하는 경우 힙 영역의 위치를 가리키는 주소를 복제 합니다.
변수명은 다르지만 힙 영역에 동일한 객체를 가리키게 되고, 일치 연산자로 cat == cat2 를 하면 true 를 출력하게 됩니다.

Javascript가 참조타입의 데이터를 메모리에 저장하는 이러한 특징 때문에 주의해야 합니다.
위의 경우 cat과 cat2가 하나의 객체를 가리키고 있기 때문에 cat을 수정할 경우 cat2에도 수정된 데이터가 출력되기 때문입니다.

이뉴는 같은 주소를 가리키며 동일한 객체를 공유하고 있기 때문입니다.

이 처럼 객체가 지정된 주소를 복제하는 것을 얕은 복제 라고 합니다.

주소 복제 아닌 다른 메모리에 객체를 똑같이 복제하고 싶다면 깊ㅇ느 복제, Deep Copy를 해야 합니다.
변수명을 복제하지 않고, 객체에 속한 모든 내용을 복제할 수 있고, 이 때 객체 프로퍼티에 참조값이 저장되어 있는 부분을 주의햐 복제를 진행해야 합니다.

객체의 프로퍼티의 값에는 Javascript에서 사용할 수 있는 모든 값들이 사용 가능 합니다.
원시형인 경우 그대로 복제를 진행하면 됩니다. 값이 원시형이 아닌 경우에는 레퍼런스 주소 내부의 값을 복제해 진행할 수 있습니다.
---

React-Hook.html :star2:

[![Star This Project](https://img.shields.io/github/stars/kitian616/jekyll-TeXt-theme.svg?label=Stars&style=social)](https://github.com/canyon920/)